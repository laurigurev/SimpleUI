#include "sui.h"

struct sui_glyph cdata[] = {
	{ 32 , 63 , 48 , 24, 1 , -8 , 14 , 8 }, 
	{ 33 , 83 , 31 , 4 , 9 , 2  , 3  , 8 }, 
	{ 34 , 105, 39 , 6 , 3 , 1  , 3  , 8 }, 
	{ 35 , 8  , 14 , 7 , 9 , 1  , 3  , 8 }, 
	{ 36 , 0  , 0  , 6 , 13, 1  , 1  , 8 }, 
	{ 37 , 26 , 0  , 8 , 11, 0  , 2  , 8 }, 
	{ 38 , 16 , 13 , 7 , 9 , 1  , 3  , 8 }, 
	{ 39 , 125, 10 , 2 , 3 , 3  , 3  , 8 }, 
	{ 40 , 54 , 0  , 4 , 11, 2  , 3  , 8 }, 
	{ 41 , 59 , 0  , 4 , 11, 2  , 3  , 8 }, 
	{ 42 , 63 , 42 , 7 , 5 , 1  , 5  , 8 }, 
	{ 43 , 71 , 41 , 6 , 5 , 1  , 5  , 8 }, 
	{ 44 , 78 , 41 , 3 , 4 , 3  , 10 , 8 }, 
	{ 45 , 121, 39 , 6 , 1 , 1  , 7  , 8 }, 
	{ 46 , 117, 39 , 3 , 2 , 3  , 10 , 8 }, 
	{ 47 , 86 , 0  , 6 , 10, 1  , 3  , 8 }, 
	{ 48 , 62 , 12 , 6 , 9 , 2  , 3  , 8 }, 
	{ 49 , 77 , 31 , 5 , 9 , 1  , 3  , 8 }, 
	{ 50 , 69 , 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 51 , 76 , 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 52 , 32 , 12 , 7 , 9 , 1  , 3  , 8 }, 
	{ 53 , 83 , 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 54 , 90 , 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 55 , 97 , 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 56 , 48 , 12 , 6 , 9 , 1  , 3  , 8 }, 
	{ 57 , 104, 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 58 , 122, 30 , 3 , 7 , 3  , 5  , 8 }, 
	{ 59 , 88 , 31 , 3 , 9 , 3  , 5  , 8 }, 
	{ 60 , 111, 11 , 6 , 9 , 1  , 3  , 8 }, 
	{ 61 , 91 , 41 , 6 , 3 , 1  , 6  , 8 }, 
	{ 62 , 118, 10 , 6 , 9 , 1  , 3  , 8 }, 
	{ 63 , 0  , 24 , 6 , 9 , 1  , 3  , 8 }, 
	{ 64 , 114, 0  , 8 , 9 , 0  , 3  , 8 }, 
	{ 65 , 7  , 24 , 6 , 9 , 1  , 3  , 8 }, 
	{ 66 , 14 , 24 , 6 , 9 , 1  , 3  , 8 }, 
	{ 67 , 21 , 23 , 6 , 9 , 1  , 3  , 8 }, 
	{ 68 , 55 , 12 , 6 , 9 , 1  , 3  , 8 }, 
	{ 69 , 28 , 23 , 6 , 9 , 1  , 3  , 8 }, 
	{ 70 , 35 , 22 , 6 , 9 , 1  , 3  , 8 }, 
	{ 71 , 42 , 22 , 6 , 9 , 1  , 3  , 8 }, 
	{ 72 , 49 , 22 , 6 , 9 , 1  , 3  , 8 }, 
	{ 73 , 123, 0  , 4 , 9 , 2  , 3  , 8 }, 
	{ 74 , 56 , 22 , 6 , 9 , 1  , 3  , 8 }, 
	{ 75 , 63 , 22 , 6 , 9 , 1  , 3  , 8 }, 
	{ 76 , 70 , 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 77 , 0  , 14 , 7 , 9 , 1  , 3  , 8 }, 
	{ 78 , 40 , 12 , 7 , 9 , 1  , 3  , 8 }, 
	{ 79 , 77 , 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 80 , 21 , 33 , 6 , 9 , 1  , 3  , 8 }, 
	{ 81 , 35 , 0  , 6 , 11, 1  , 3  , 8 }, 
	{ 82 , 91 , 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 83 , 98 , 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 84 , 105, 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 85 , 112, 21 , 6 , 9 , 1  , 3  , 8 }, 
	{ 86 , 119, 20 , 6 , 9 , 1  , 3  , 8 }, 
	{ 87 , 24 , 13 , 7 , 9 , 1  , 3  , 8 }, 
	{ 88 , 0  , 34 , 6 , 9 , 1  , 3  , 8 }, 
	{ 89 , 7  , 34 , 6 , 9 , 1  , 3  , 8 }, 
	{ 90 , 14 , 34 , 6 , 9 , 1  , 3  , 8 }, 
	{ 91 , 18 , 0  , 4 , 12, 2  , 3  , 8 }, 
	{ 92 , 100, 0  , 6 , 10, 1  , 3  , 8 }, 
	{ 93 , 13 , 0  , 4 , 12, 2  , 3  , 8 }, 
	{ 94 , 98 , 39 , 6 , 3 , 1  , 1  , 8 }, 
	{ 95 , 88 , 45 , 8 , 1 , 0  , 14 , 8 }, 
	{ 96 , 112, 39 , 4 , 3 , 2  , 1  , 8 }, 
	{ 97 , 108, 31 , 6 , 7 , 1  , 5  , 8 }, 
	{ 98 , 28 , 33 , 6 , 9 , 1  , 3  , 8 }, 
	{ 99 , 115, 31 , 6 , 7 , 1  , 5  , 8 }, 
	{ 100, 35 , 32 , 6 , 9 , 1  , 3  , 8 }, 
	{ 101, 0  , 44 , 6 , 7 , 1  , 5  , 8 }, 
	{ 102, 42 , 32 , 6 , 9 , 1  , 3  , 8 }, 
	{ 103, 107, 0  , 6 , 10, 1  , 5  , 8 }, 
	{ 104, 49 , 32 , 6 , 9 , 1  , 3  , 8 }, 
	{ 105, 93 , 0  , 6 , 10, 1  , 2  , 8 }, 
	{ 106, 7  , 0  , 5 , 13, 1  , 2  , 8 }, 
	{ 107, 56 , 32 , 6 , 9 , 1  , 3  , 8 }, 
	{ 108, 63 , 32 , 6 , 9 , 1  , 3  , 8 }, 
	{ 109, 92 , 31 , 7 , 7 , 1  , 5  , 8 }, 
	{ 110, 7  , 44 , 6 , 7 , 1  , 5  , 8 }, 
	{ 111, 14 , 44 , 6 , 7 , 1  , 5  , 8 }, 
	{ 112, 79 , 0  , 6 , 10, 1  , 5  , 8 }, 
	{ 113, 72 , 0  , 6 , 10, 1  , 5  , 8 }, 
	{ 114, 21 , 43 , 6 , 7 , 1  , 5  , 8 }, 
	{ 115, 56 , 42 , 6 , 7 , 1  , 5  , 8 }, 
	{ 116, 70 , 31 , 6 , 9 , 1  , 3  , 8 }, 
	{ 117, 28 , 43 , 6 , 7 , 1  , 5  , 8 }, 
	{ 118, 35 , 42 , 6 , 7 , 1  , 5  , 8 }, 
	{ 119, 100, 31 , 7 , 7 , 1  , 5  , 8 }, 
	{ 120, 42 , 42 , 6 , 7 , 1  , 5  , 8 }, 
	{ 121, 64 , 0  , 7 , 10, 0  , 5  , 8 }, 
	{ 122, 49 , 42 , 6 , 7 , 1  , 5  , 8 }, 
	{ 123, 48 , 0  , 5 , 11, 1  , 3  , 8 }, 
	{ 124, 23 , 0  , 2 , 12, 3  , 3  , 8 }, 
	{ 125, 42 , 0  , 5 , 11, 2  , 3  , 8 }, 
	{ 126, 82 , 41 , 8 , 3 , 0  , 3  , 8 }, 
	{ 127, 84 , 21 , 6 , 9 , 1  , 3  , 8 }
};

#include <string.h>
#include <d3dcompiler.h>
#define HANDMADE_MATH_IMPLEMENTATION
#include "HandmadeMath.h"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

void sui_init(struct sui_context* sui, ID3D11Device* d11device, i32 w, i32 h)
{
	memset(sui, 0, sizeof(struct sui_context));

	sui->vertices = (struct sui_vertex*)malloc(sizeof(struct sui_vertex) * 2048);
	sui->vlen = 0;

	sui->viewport = (struct sui_viewport){ w, h };

	/* sui->io.rclick_delta = CLICK_DELTA_RESET;
	sui->io.lclick_delta = CLICK_DELTA_RESET; */

	sui->d11device = d11device;
	ID3D11Device_GetImmediateContext(d11device, &sui->d11context);

	{
		HRESULT hr;

		const char* vs =
			"cbuffer ConstantBuffer : register(b0) {\
				float4x4 proj;\
			};\
			\
			struct VS_INPUT {\
				float2 position : POSITION0;\
				float2 uv : TEXCOORD0;\
				float4 color : COLOR0;\
			};\
			\
			struct VS_OUTPUT {\
				float2 uv : TEXCOORD0;\
				float4 color : COLOR0;\
				float4 position : SV_POSITION;\
			};\
			\
			VS_OUTPUT main(VS_INPUT vsin) {\
				VS_OUTPUT vsout;\
				vsout.position = mul(proj, float4(vsin.position, 0.0, 1.0));\
				vsout.color = vsin.color;\
				vsout.uv = vsin.uv;\
				return vsout;\
			}";

		ID3DBlob* blob = NULL;
		hr = D3DCompile(
			vs, strlen(vs), NULL, NULL, NULL, "main",
			"vs_4_0", 0 /* deal with shader flags later */, 0, &blob, NULL
		);
		sui_assert(hr == 0);

		hr = ID3D11Device_CreateVertexShader(
			d11device,
			(void*)ID3D10Blob_GetBufferPointer(blob),
			ID3D10Blob_GetBufferSize(blob),
			NULL,
			&sui->d11vs
		);
		sui_assert(hr == 0);

		D3D11_INPUT_ELEMENT_DESC ieds[] = {
			{ 
				"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 
				D3D11_APPEND_ALIGNED_ELEMENT, 
				D3D11_INPUT_PER_VERTEX_DATA, 0
			},
			{ 
				"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 
				D3D11_APPEND_ALIGNED_ELEMENT, 
				D3D11_INPUT_PER_VERTEX_DATA, 0
			},

			{ 
				"COLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 
				D3D11_APPEND_ALIGNED_ELEMENT, 
				D3D11_INPUT_PER_VERTEX_DATA, 0
			},
		};
		hr = ID3D11Device_CreateInputLayout(
			d11device, ieds, 3,
			ID3D10Blob_GetBufferPointer(blob),
			ID3D10Blob_GetBufferSize(blob),
			&sui->d11il
		);
		sui_assert(hr == 0);
		
		const char* ps =
			"Texture2D tex;\
			SamplerState samp;\
			struct PS_INPUT {\
				float2 uv : TEXCOORD0;\
				float4 color : COLOR0;\
			};\
			\
			float4 main(PS_INPUT psin) : SV_TARGET {\
				float a = tex.Sample(samp, psin.uv).x;\
				return psin.color * a;\
			}";

		hr = D3DCompile(
			ps, strlen(ps), NULL, NULL, NULL, "main",
			"ps_4_0", 0 /* deal with shader flags later */, 0, &blob, NULL
		);
		sui_assert(hr == 0);

		hr = ID3D11Device_CreatePixelShader(
			d11device,
			ID3D10Blob_GetBufferPointer(blob),
			ID3D10Blob_GetBufferSize(blob),
			NULL,
			&sui->d11ps
		);
		sui_assert(hr == 0);

		ID3D10Blob_Release(blob);

		// blending
		D3D11_BLEND_DESC bdesc;
		memset(&bdesc, 0, sizeof(D3D11_BLEND_DESC));
		bdesc.RenderTarget[0].BlendEnable = 1;
		bdesc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
		bdesc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
		bdesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
		bdesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
		bdesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
		bdesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
		bdesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
		
		hr = ID3D11Device_CreateBlendState(d11device, &bdesc, &sui->d11bs);
		sui_assert(hr == 0);

		// font atlas
		i32 n;
		const char* file = "Fixedsys.png";
		u8* bmp = stbi_load(file, &sui->img_w, &sui->img_h, &n, 0);
		sui->img_wf = (f32)sui->img_w;
		sui->img_hf = (f32)sui->img_h;

		D3D11_TEXTURE2D_DESC texture_desc;
		texture_desc.Width = sui->img_w;
		texture_desc.Height = sui->img_h;
		texture_desc.MipLevels = 1;
		texture_desc.ArraySize = 1;
		texture_desc.Format = DXGI_FORMAT_R8_UNORM;
		texture_desc.SampleDesc = (DXGI_SAMPLE_DESC){ 1, 0 };
		texture_desc.Usage = D3D11_USAGE_DEFAULT;
		texture_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
		texture_desc.CPUAccessFlags = 0;
		texture_desc.MiscFlags = 0;

		D3D11_SUBRESOURCE_DATA sub_data;
		sub_data.pSysMem = bmp;
		sub_data.SysMemPitch = sui->img_w;
		sub_data.SysMemSlicePitch = 0;

		ID3D11Texture2D* texture;
		hr = ID3D11Device_CreateTexture2D(
			d11device, &texture_desc, &sub_data, &texture
		);
		sui_assert(hr == 0);
		
		D3D11_SHADER_RESOURCE_VIEW_DESC srvd;
		srvd.Format = texture_desc.Format;
		srvd.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
		srvd.Texture2D = (D3D11_TEX2D_SRV){ 0, 1 };

		hr = ID3D11Device_CreateShaderResourceView(
			d11device, texture, &srvd, &sui->view);
		sui_assert(hr == 0);

		D3D11_SAMPLER_DESC sampler_desc;
		memset(&sampler_desc, 0, sizeof(D3D11_SAMPLER_DESC));
		sampler_desc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
		sampler_desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
		sampler_desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
		sampler_desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
		// sampler_desc.MipLODBias = 0;
		// sampler_desc.MaxAnisotropy = 0;
		// sampler_desc.ComparisonFunc = 0;
		// sampler_desc.BorderColor = 0;
		// sampler_desc.MinLOD;
		// sampler_desc.MaxLOD;
		 
		hr = ID3D11Device_CreateSamplerState(
			d11device, &sampler_desc, &sui->sampler);
		sui_assert(hr == 0);
		
		ID3D11Texture2D_Release(texture);
		stbi_image_free(bmp);
	}

	{
		HRESULT hr;

		D3D11_BUFFER_DESC bufdsc;
		bufdsc.ByteWidth = sizeof(struct sui_vertex) * 2048;
		bufdsc.Usage = D3D11_USAGE_DYNAMIC;
		bufdsc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		bufdsc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		bufdsc.MiscFlags = 0;
		bufdsc.StructureByteStride = 0;
		
		hr = ID3D11Device_CreateBuffer(d11device, &bufdsc, NULL, &sui->d11vb);
		sui_assert(hr == 0);

		u32 indices[] = { 0, 1, 2, 0, 3, 1 };

		bufdsc.ByteWidth = sizeof(u32) * 6;
		bufdsc.Usage = D3D11_USAGE_DEFAULT;
		bufdsc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		bufdsc.CPUAccessFlags = 0;
		bufdsc.MiscFlags = 0;
		bufdsc.StructureByteStride = 0;
		
		D3D11_SUBRESOURCE_DATA subrsc;
		subrsc.pSysMem = indices;
		subrsc.SysMemPitch = 0;
		subrsc.SysMemSlicePitch = 0;

		hr = ID3D11Device_CreateBuffer(d11device, &bufdsc, &subrsc, &sui->d11ib);
		sui_assert(hr == 0);

		// orthographic projection matrix
		float L = 0;
		float R = sui->viewport.w;
		float T = 0;
		float B = sui->viewport.h;
		float proj[4][4] = {
			{ 2.0f/(R-L),  0.0f,        0.0f, 0.0f },
			{ 0.0f,        2.0f/(T-B),  0.0f, 0.0f },
			{ 0.0f,        0.0f,        0.5f, 0.0f },
			{ (R+L)/(L-R), (T+B)/(B-T), 0.5f, 1.0f }
		}; 

		// hmm_mat4 proj = HMM_Orthographic(L, R, B, T, 0.5f, 0.5f);
		bufdsc.ByteWidth = sizeof(proj);
		bufdsc.Usage = D3D11_USAGE_DEFAULT;
		bufdsc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		bufdsc.CPUAccessFlags = 0;
		bufdsc.MiscFlags = 0;
		bufdsc.StructureByteStride = 0;
		
		subrsc.pSysMem = proj;
		subrsc.SysMemPitch = 0;
		subrsc.SysMemSlicePitch = 0;

		hr = ID3D11Device_CreateBuffer(d11device, &bufdsc, &subrsc, &sui->d11cb);
		sui_assert(hr == 0);

	}
}

void sui_terminate(struct sui_context* sui)
{
	sui->d11device = NULL;
	sui->d11context = NULL;

	ID3D11VertexShader_Release(sui->d11vs);
	ID3D11InputLayout_Release(sui->d11il);
	ID3D11PixelShader_Release(sui->d11ps);

	ID3D11Buffer_Release(sui->d11vb);
	ID3D11Buffer_Release(sui->d11ib);
	ID3D11Buffer_Release(sui->d11cb);

	ID3D11BlendState_Release(sui->d11bs);
	ID3D11ShaderResourceView_Release(sui->view);
	ID3D11SamplerState_Release(sui->sampler);

	sui->vlen = 0;
	free(sui->vertices);

	memset(sui, 0, sizeof(struct sui_context));
}

void sui_input(struct sui_context* sui, i16 mx, i16 my, u8 rdown, u8 rup, u8 ldown, u8 lup)
{
	sui->io.dmx = sui->io.mx - mx;
	sui->io.dmy = sui->io.my - my;

	sui->io.mx = mx;
	sui->io.my = my;

	sui->io.rdown = rdown;
	sui->io.rup = rup;
	sui->io.ldown = ldown;
	sui->io.lup = lup;
	sui->io.rclicked = 0;
	sui->io.lclicked = 0;

	if (rdown) sui->io.rheld = 1; 
	else if (rup) sui->io.rheld = 0; 

	if (ldown) sui->io.lheld = 1; 
	else if (lup) sui->io.lheld = 0; 

	if (rdown) sui->io.rclick_time = sui_time_begin();
	if (rup) sui->io.rclick_time = sui_time_end(sui->io.rclick_time);
	
	if (ldown) sui->io.lclick_time = sui_time_begin();
	if (lup) sui->io.lclick_time = sui_time_end(sui->io.lclick_time);

	if (sui->io.rclick_time != 0 && sui->io.rclick_time < 200000) {
		sui->io.rclicked = 1;
		sui->io.rclick_time = 0;
	}
	if (sui->io.lclick_time != 0 && sui->io.lclick_time < 200000) {
		sui->io.lclicked = 1;
		sui->io.lclick_time = 0;
	}
}

struct sui_widget sui_create_widget(char* str, struct sui_color color, struct sui_color hover_color,
                                    struct sui_color bg_color, struct sui_color hover_bg_color)
{
        struct sui_widget widget;
        widget.str = str;
        widget.color = color;
        widget.hover_color = hover_color;
        widget.bg_color = bg_color;
        widget.hover_bg_color = hover_bg_color;
        widget.pad_left = 50.0f;
        widget.pad_right = 50.0f;
        widget.pad_top = 20.0f;
        widget.pad_bottom = 20.0f;
        widget.margin_left = 10.0f;
        widget.margin_right = 10.0f;
        widget.margin_top = 10.0f;
        widget.margin_bottom = 10.0f;
        widget.root = NULL;
        widget.rect = (union sui_rect){ 0.0f, 0.0f, 0.0f, 0.0f };        
        widget.bbox = (union sui_rect){ 0.0f, 0.0f, 0.0f, 0.0f };        
	widget.held = 0;
        widget.pressed = 0;
        widget.released = 0;
        widget.hovering = 0;
        widget.clicked = 0;
        return widget;
}

struct sui_window sui_create_window(char* str, struct sui_color color, struct sui_color hover_color,
                                    struct sui_color bg_color, struct sui_color hover_bg_color)
{
        struct sui_window window;
        window.widget = sui_create_widget(str, color, hover_color, bg_color, hover_bg_color);
        window.p_vertex = 0;
	window.current_w = 0.0f;
	window.current_h = 0.0f;
	window.current_max_h = 0.0f;
        return window;
}

void sui_begin(struct sui_context* sui, struct sui_window* window, f32 x, f32 y)
{
        sui_assert(sui);
        sui_assert(window);
        
        // if (sui->current_window) window->widget.root = sui->current_window;
        window->widget.root = sui->current_window;
	/* if (sui->current_window) {
		x += sui->current_window->widget.rect.x;
		y += sui->current_window->widget.rect.y;
	} */
        window->widget.rect.x = x;
        window->widget.rect.y = y;
        window->p_vertex = sui->vertices + sui->vlen;
	window->current_w = 0.0f;
	window->current_h = 0.0f;
	window->current_max_h = 0.0f;
        
        sui->current_window = window;       
        sui->vlen += 4;
}

void sui_end(struct sui_context* sui)
{
        sui_assert(sui);
        
        struct sui_window* window = sui->current_window;
	window->widget.rect.w = sui_max(window->current_w, window->widget.rect.w);
	// window->widget.rect.h = sui_max(window->current_h, window->widget.rect.h);
	window->widget.rect.h += window->current_max_h;
        sui_putr(window->p_vertex, window->widget.rect, window->widget.color);
        window->widget.rect = (union sui_rect){ 0.0f, 0.0f, 0.0f, 0.0f };
        sui->current_window = window->widget.root;
}

void sui_row(struct sui_context* sui)
{
        struct sui_window* window = sui->current_window;
	
	window->widget.rect.w = sui_max(window->current_w, window->widget.rect.w);
	window->current_w = 0.0f;
	
	window->widget.rect.h += window->current_max_h;
	window->current_h = window->widget.rect.h;
	window->current_max_h = 0.0f;
}

union sui_rect sui_getuv(char c, f32 w, f32 h)
{
        struct sui_glyph glyph = cdata[c - 32];
        
        f32 tmp_x = glyph.x / w;
        f32 tmp_y = glyph.y / h;
        f32 tmp_w = glyph.width / w;
        f32 tmp_h = glyph.height / h;    
        
        union sui_rect uv;
        uv.u0 = tmp_x;
        uv.u1 = tmp_x + tmp_w;
        uv.v0 = tmp_y;
        uv.v1 = tmp_y + tmp_h;
        
        return uv;
}

void sui_putr(struct sui_vertex* vertex, union sui_rect rect, struct sui_color color)
{
        f32 x0 = rect.x;
        f32 x1 = rect.x + rect.w;
        f32 y0 = rect.y;
        f32 y1 = rect.y + rect.h;

        // TODO: deal with different w ja h for different font atlases
        union sui_rect uv = sui_getuv(127, 128.0f, 64.0f);

	*vertex++ = (struct sui_vertex){ x0, y0, uv.u0, uv.v0, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ x1, y1, uv.u1, uv.v1, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ x0, y1, uv.u0, uv.v1, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ x1, y0, uv.u1, uv.v0, color.r, color.g, color.b, color.a };
}

f32 sui_putc(struct sui_vertex* vertex, char c, f32 x, f32 y, struct sui_color color)
{
        const f32 img_w = 128.0f;
        const f32 img_h = 64.0f;
        struct sui_glyph glyph = cdata[c - 32];

        union sui_rect rect = { x + glyph.xoffset, y + glyph.yoffset, glyph.width, glyph.height };
        
        f32 tmp_x = glyph.x / img_w;
        f32 tmp_y = glyph.y / img_h;
        f32 tmp_w = glyph.width / img_w;
        f32 tmp_h = glyph.height / img_h;
        
        union sui_rect uv;
        uv.u0 = tmp_x;
        uv.u1 = tmp_x + tmp_w;
        uv.v0 = tmp_y;
        uv.v1 = tmp_y + tmp_h;
        
	*vertex++ = (struct sui_vertex){ rect.x, rect.y, uv.u0, uv.v0, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ rect.x + rect.w, rect.y + rect.h, uv.u1, uv.v1, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ rect.x, rect.y + rect.h, uv.u0, uv.v1, color.r, color.g, color.b, color.a };
	*vertex++ = (struct sui_vertex){ rect.x + rect.w, rect.y, uv.u1, uv.v0, color.r, color.g, color.b, color.a };

        return (f32)glyph.xadvance;
}

i32 sui_overlap(union sui_rect bbox, f32 mx, f32 my)
{
	if (bbox.x0 < mx && bbox.x1 > mx && bbox.y0 < my && bbox.y1 > my) {
		return 1;
	}
	return 0;
}

i64 sui_time_begin()
{
	LARGE_INTEGER frequency;
	QueryPerformanceFrequency(&frequency);
	LARGE_INTEGER t;
	QueryPerformanceCounter(&t);
	return t.QuadPart;
}

i64 sui_time_end(i64 begin)
{
	LARGE_INTEGER frequency;
	QueryPerformanceFrequency(&frequency);
	LARGE_INTEGER time;
	QueryPerformanceCounter(&time);
	i64 res = time.QuadPart;
	res -= begin;
	res *= 1000000;
	res /= frequency.QuadPart;
	return res;
}

void sui_button(struct sui_context* sui, struct sui_widget* widget)
{
        sui_assert(sui);
        sui_assert(widget);

	struct sui_window* root = sui->current_window;
        union sui_rect root_rect = root->widget.rect;
	
	char* aux = widget->str;
	f32 x = root_rect.x + root->current_w + widget->margin_left;
	f32 y = root_rect.y + root->current_h + widget->margin_top;
	f32 w = widget->pad_left + widget->pad_right;
	f32 h = 16.0f + widget->pad_top + widget->pad_bottom;
	// f32 w = 0.0f;
	// f32 h = 16.0f;
	while (*aux) { w += cdata[*aux++ - 32].xadvance; }
	union sui_rect rect = (union sui_rect){ x, y, w, h };
	union sui_rect bbox = (union sui_rect){ x, x + w, y, y + h };
	widget->rect = rect;
	widget->bbox = bbox;

	i32 overlap = sui_overlap(bbox, (f32)sui->io.mx, (f32)sui->io.my);
        struct sui_color bg_color = widget->bg_color;
	struct sui_color color = widget->color;
	memset(&widget->pressed, 0, 4);
	if (overlap) {
		if (sui->io.ldown) { widget->pressed = 1; widget->held = 1; }
		if (sui->io.lup && widget->held) { widget->released = 1; widget->held = 0; }
		widget->hovering = 1;
	}
	if (widget->hovering) {
		bg_color = widget->hover_bg_color;
		color = widget->hover_color;
	}
	if (widget->released && sui->io.lclicked) widget->clicked = 1;
		
	struct sui_vertex* vertex = sui->vertices + sui->vlen;
	sui->vlen += 4;
	sui_putr(vertex, rect, bg_color);
	vertex += 4;
	aux = widget->str;
	
	x += widget->pad_left;
	y += widget->pad_top;
	w = 0.0f;
	while (*aux) { 
		w += sui_putc(vertex, *aux++, x + w, y, color); 
		vertex +=4; 
		sui->vlen += 4;
	}

	root->current_w += w + (widget->pad_left + widget->pad_right) + (widget->margin_left + widget->margin_right);
	root->current_max_h = sui_max((h + widget->margin_top + widget->margin_bottom), root->current_max_h);
}

void sui_render(struct sui_context* sui)
{
	HRESULT hr;
	D3D11_MAPPED_SUBRESOURCE vtx_rsc;
	hr = ID3D11DeviceContext_Map(
		sui->d11context, sui->d11vb, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_rsc
	);
	sui_assert(hr == 0);
	memcpy(vtx_rsc.pData, sui->vertices, sui->vlen * sizeof(struct sui_vertex));
	ID3D11DeviceContext_Unmap(sui->d11context, sui->d11vb, 0);

	ID3D11DeviceContext_IASetPrimitiveTopology(
		sui->d11context, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST
	);
	ID3D11DeviceContext_IASetInputLayout(sui->d11context, sui->d11il);
	ID3D11DeviceContext_VSSetShader(sui->d11context, sui->d11vs, NULL, 0);
	ID3D11DeviceContext_PSSetShader(sui->d11context, sui->d11ps, NULL, 0);
	ID3D11DeviceContext_IASetIndexBuffer(
		sui->d11context, sui->d11ib, DXGI_FORMAT_R32_UINT, 0
	);
	ID3D11DeviceContext_VSSetConstantBuffers(sui->d11context, 0, 1, &sui->d11cb);
	ID3D11DeviceContext_OMSetBlendState(sui->d11context, sui->d11bs, 0, 0xffffffff);
	ID3D11DeviceContext_PSSetShaderResources(sui->d11context, 0, 1, &sui->view);
	ID3D11DeviceContext_PSSetSamplers(sui->d11context, 0, 1, &sui->sampler);


	u32 stride = sizeof(struct sui_vertex);
	u32 offset = 0;
	for (i32 i = 0; i < sui->vlen; i += 4) {
		offset = i * stride;
		ID3D11DeviceContext_IASetVertexBuffers(
			sui->d11context, 0, 1, &sui->d11vb, &stride, &offset
		);
		ID3D11DeviceContext_DrawIndexed(sui->d11context, 6, 0, 0);
	}
	// memset(sui->vertices, 0, sizeof(struct sui_vertex) * sui->vlen);
	sui->vlen = 0;
}